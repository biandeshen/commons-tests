### Java代码编写要点

<hr/>

#### 创建与销毁
1. 避免创建不必要的对象，要优先使用基本类型而不是装箱基本类型，小心无意识的自动装箱。
2. 静态工厂方法替代构造器 
3. 多个构造器参数使用Builder创建
4. 私有构造器强化不可实例化能力
5. 单例类需要可序列化时，必须声明所有实例域都是瞬时的，并提供一个readResolve()方法
6. 静态工具类和Singleton类不适合需要引用底层资源的类
7. 引入底层资源时应优先使用依赖注入（构造方法注入-即构造方法的参数为成员变量赋值，Setter方法注入-默认以无参构造方法创建实例，然后以setter方法赋值）
8. 警惕自身管理内存的类、缓存以及监听器和其他回调，易产生内存泄漏问题
9. 避免使用终结方法(finalizer)和清除方法(cleaner)，不可预期且运行缓慢、性能损耗严重，耗时任务不应由此来完成，避免以此更新持久状态
10. 需要终止时，应让类实现AutoCloseable
11. try-with-resources优先于try-finally

---

#### 所有对象通用
1. 覆盖equals时遵守通用约定
2. 不应覆盖equals方法的条件  
    2.1 类的每个实例本质唯一 例如：Thread
    2.2 类没有必要提供“逻辑相等” 例如： java.util.regex.Pattern
    2.3 父类已经覆盖了equals，父类的行为对这个类也同样合适 例如：Set、List、Map
    2.4 类是私有的，或者是包级私有的，可以确定equals方法拥有不会被调用 规避风险： 覆盖equals方法，并快速失败
3. 覆盖equals时总要覆盖hashCode，Objects.hash方法由于会引发数组的创建，或基本类型的装箱拆箱，影响性能。
4. 始终覆盖toString方法，返回对象中包含的值得关注的信息
5. 谨慎覆盖clone，即拷贝。clone属于另一种形式的构造器，要确保它不会伤害到原始对象。不可变类永远不应提供clone方法。通过super.clone()生成克隆对象，因为Java支持协变返回类型，即覆盖方法的返回类型可以是被覆盖方法的返回类型的子类。super.clone()应包含在try-catch块中，Cloneable架构与引用可变对象的final域的正常用法是不兼容的。公有的clone方法应该省略throws声明。（更多参见《EffectiveJava第三版》书第13条）
6. 考虑实现Comparable接口，Java 7版本中，已经在所有装箱基本类型汇总增加了静态的Compare方法。在compareTo方法中使用<和>非常烦琐，不建议使用
7. 协变的作用就是可以将子类泛型隐式转换为父类泛型，而逆变就是将父类泛型隐式转换为子类泛型。逆变和协变还有两点：协变时泛型无法作为参数、逆变时泛型无法作为返回值。

---

#### 类和接口
1. 尽可能使每个类或成员不被外界访问
2. 包含公有可变域的类通常不是线程安全的
3. 让类具有公有的静态final数组域，或返回这种域的访问方法，这是错误的。具有这样的域或方法，客户将能够修改数组内容。方法应返回数组的不可变列表或拷贝。
4. 要在公有类而非公有域中使用访问方法。即类若可以在它所在的包之外进行访问，就应提供访问方法。若包级私有或私有的嵌套类，则暴露数据域实际并无本质的错误。公有类永远都不应该暴露可变的域。
5. 类成为不可变（String、基本类型的包装类，BigInteger和BigDecimal），遵循以下五条规则：
    1. 不提供任何会修改对象状态的方法（也称为设值方法）
    2. 保证类不会被扩展
    3. 声明所有的域都是final的
    4. 声明所有的域都是私有的
    5. 确保对应任何可变组件的互斥访问
6. 不可变对象本质是线程安全的，它们不要求同步，不可变对象可以被自由的共享,也可以共享它们的内部信息，不可变对象为其他对象提供了大量的构件，无偿提供失败的原子性 缺点：每个不同值需要一个单独的对象
7. 不要为每个get方法编写一个相应的set方法，除非有理由让类成为可变的类，否则它就应该是不可变的。若类不能成为不可变的，仍应尽可能限制它的可变性。除非理由充足，否则每个域都应为private final的。
8. 构造器应创建完全初始化的对象，并建立起所有的约束关系
9. 继承打破了封装性，子类会根据父类的更新而演变，子类容易遭到破坏
10. 复合优先于继承，不扩展现有类，而是在新的类中增加私有域，它引用现有类的一个实例。将现有类变成新类的一个组件，新类汇总每个实例方法都可以调用被包含的现有类实例中对应的方法，并返回它的结果，这被称为转发，新类汇总的方法被称为转发方法。新的类被称为包装类（复合+转发 宽松的称为 ‘委托’，但并不），也正是装饰者模式，包装类不适合用于回调框架。
11. 只有当子类真正是超类的子类型时，才适合用继承。
12. 禁止子类化的两种方式，一种是把类声明为final，一种是把所有的构造器都变成私有的，或者包级私有的，并增加一些公有的静态工厂来替代构造器。
13. 类易更新，以实现新的接口，而一般来说，无法更新现有的类来扩展新的抽象类，提高抽象类层次则会伤害到类层次。
14. 接口是订阅mixin（混合类型）的理想选择。mixin类型是指：类除了实现它的“基本类型”之外，还可以实现mixin类型，表明它提供了某些可供选择的行为。（例：Comparable是mixin接口，允许类表明它的实例可以与其他的可相互比较的类进行排序。）这样的接口被称为mixin，是因为它允许任选的功能可被混合到类型的主要功能中。由于类不能有一个以上的父类，类层次中也没有合适的位置插入mixin，所以抽象类不能被用于定义mixin。
15. 接口允许构造非层次结构的类型框架（实现多个接口）。接口使得安全地增强类的功能成为可能。
16. 通过对接口提供一个抽象的骨架实现类，可以把接口和抽象类的优点结合起来，接口负责定义类型，或许还提供一些缺省方法，而骨架实现类则负责实现除基本类型接口方法之外，剩下的非基本类型接口方法。扩展骨架实现占了实现接口之外的大部分工作，这就是模板方法模式。
17. 骨架实现类惯例被称为AbstractInterface，这里的Interface指的是所实现的接口的名字。骨架可以使程序员非常容易地提供自己的接口实现。
18. 模拟多重继承，与复合（包装类模式）密切相关，实现了骨架实现类的类可以把对接口方法的调用转发到一个内部私有类的实例上（复合，此时实例为自身实现extends了骨架实现类的内部私有类），这项技术具有多重继承的绝大多数优点，同时又避免了相应的缺陷。
19. 为接口提供缺省方法构造，允许给现有的接口添加方法。缺省方法的声明中包括一个缺省实现，给实现接口但未实现默认方法的所有类使用。有了缺省方法，接口的现有实现就不会出现编译时无警告和报错，运行时却失败的情况。(谨慎的接口设计仍然是至关重要的，或许接口发布后也能够纠正，但是不要指望...)
20. 接口应该只被用来定义类型，不应该被用来导出常量。
21. 常量接口模式是对接口的不良使用！（下划线配合数字字面量使用，如 6.022_140_857e23）
    1. 如果常量与某个现有的类或接口紧密相关，应该把常量添加到这个类或接口中。
    2. 如果这些常量最好被看作枚举类型的成员，就应该使用枚举类型来导出。
    3. 否则，应该使用不可实例化的工具类来导出这些常量
    4. 工具类长要求客户端用类名修饰常量名，如：PhysicalConstants.AVOGADROS_NUMBER(物理常数-阿伏伽德罗数)，如果大量利用工具类导出的常量，可以利用静态导入机制，避免用类名来修饰常量名，如：import static com.effectivejava.secience.PhysicalConstants.*;
22. 类层次优于标签类，标签类过于冗长、容易出错，且效率低下，标签类正是对类层次的一种简单的效仿。尽可能将包含标签域的现有类重构到一个层次结构中去。
23. 嵌套类是指定义在另一个类的内部的类。其存在目的应该只是为它的外围类提供服务。（Map.Entry这个嵌套接口的作用？结合上述多继承、复合等进行思考？）
24. 嵌套类类型
    1. 静态成员类——看作普通的类，仅声明在类的内部而已，可以访问外围类的所有成员，包括声明为私有的成员。静态成员类是外部类的一个静态成员，与其他的静态成员一样，遵守同样的可访问性规则，如果它被声明为私有的，就只能在外部类的内部才可以被访问。 常见用法： 1. 公有的辅助类，与外部类一起使用才有意义(例如： 一个基于特定于常量的方法实现的操作符枚举类，此写法参照TimeUnit，这个操作符枚举类对于计算器Calculator来说，就是一个公有静态成员类) 2. 代表外围类所代表的的对象的组件，如map中的Entry
    2. 非静态成员类——语法上看，仅与静态成员类相差修饰符static，但不同的是，非静态成员类的每个实例都隐含地与外围类的一个实例相关联。在非静态成员类的实例上，可以调用外围实例上的方法，或者利用修饰过的this构造获得外围实例的引用，如果嵌套类的实例可以在它的外围实例外单独存在，这个嵌套类就必须是静态成员类；在没有外围实例的情况下，要创建非静态成员类实例是不可能的。(具体参考《EffectiveJava第三版》第24条静态成员类优于非静态成员类) 
    3. 匿名类——没有名字，不是外围类的一个成员，不与其他的成员一起被实例化，只是在使用的同时被声明和实例化。可以出现在代码中任何运行存在表达式的地方。仅当匿名类出现在非静态环境时，才有外围实例及时它们出现在静态的环境中，也不可能拥有任何静态成员，而是拥有常量变数，常量变数是final基本类型，或被初始化成常量表达式，或者被初始化成常量表达式的字符串域。 除在声明时之外，无法将它们实例化，不能执行instanceof测试，或者任何需要命名类的其他事情。无法声明一个匿名类来实现多个接口，或者扩展一个类，并同时扩展类和实现接口。 匿名类出现在表达式中，必须保持简短。
    4. 局部类——使用最少的类。任何“可以声明局部变量”的地方，都可以声明局部类，并且局部类也遵循同样的作用域规则。与成员类一样，局部类有名字，可以被重复使用。与匿名类一样，只有当局部类在非静态环境中定义的时候，才有外围实例，它们也不能包含静态成员，同样，它们也必须非常简短，以便不影响可读性。  
    除第一种外，其他三种都称为内部类
25. 限制源文件为单个顶级类。永远不要把多个顶级类或接口放在一个源文件中。

---

#### 泛型
1. 使用原生态类型，就失掉了泛型在安全性和描述性方面的所有优势。即，如果使用List这样的原生态类型，会失掉类型安全性，但如果使用像List<Object>这样的参数化类型，则不会。
2. 必须在类文字中使用原生态类型，规范不允许使用参数化类型（允许数组类型和基本类型），即List.class、String[].class和int.class都合法，但是List<String.class>和List<?>.class不合法。 
3. 泛型编程的编译器警告
    1. 非受检转换警告（unchecked cast warning）
    2. 非受检方法调用警告
    3. 非受检参数化可变参数类型警告（unchecked parameterized vararg type warning）
    4. 非受检转换警告（unchecked conversion warning）
4. 要尽可能地消除每一个非受检异常。如果无法消除警告，同时可以证明引起警告的代码是类型安全的，（这种情况下）才可以用一个@SuppressWarnings("unchecked")注解来禁止这条警告。同时，应该始终在尽可能小的范围内使用SuppressWarnings注解。每当使用时，都应添加注释，说明为什么这么做是安全的。
5. 列表优先于数组。数组是协变的（即如果Sub为Super的子类型，那么数组类型Sub[]就是Super[]的子类型），相反，泛型是可变的（对应任意两个不同类型Type1和Type2，List<Type1>既不是List<Type2>的子类型，也不是List<Type2>超类型。 利用数组，在运行发现所犯的错误；利用列表，则可以在编译时就发现错误。
6. 创建泛型数组是非法的。数组是协变且可以具体化的；泛型是不可变的且可以被擦除的。因此，数组提供了运行时的类型安全，但是没有编译时的类型安全，反之，对于泛型也一样。
7. 优先考虑泛型方法
8. 静态工具方法尤其适合于泛型化（Collections中所有“算法”方法，例如binarySearch和sort都泛型化了）。
