对象池/享元模式
观察者模式
（装饰者模式）
动态代理
树
阻塞队列
中断及中断处理
信号量
异步
fork/join
分段锁


1. 单号需封装成对象，此对象通过享元模式或对象池获取
对象应包括以下属性：
    1只能被分配唯一一次（单号状态）：此两个要求如果能被合并，则用一个属性，此属性可以是信号量；否则拆分状态与唯一
    2分配单号的时间
    3使用者
    4创建时间
    5修改时间
2. 生成单号按规则以fork/join进行处理，并以三的规则存储在数据结构里（分析单号生成规则）    

3. 选择适当的hash方式，将单号按规则存储在四层的结构里（或其他大小的更少层）（较少时应该在需要时生成，否则数据过多）
      如第一层1000个bucket    取模12位数字
        第二层1000个bucket    取模9位数字
        第三层1000个bucket    取模6位数字
        第四层1000个bucket    取模3位数字
   参考ConcurrentHashMap的实现
 4. 单号使用时，若3的规则合适，则一次最多可以取一千条数据，同时使用过的单号存入缓存，并移除集合内的
 
 5. 获取单号时，先查询缓存，若缓存无，查询集合，在最后一个桶时，（分段锁） 锁住一千条数据。。。根据锁情况及集合数据判断是否已使用
 
 6. 将缓存中的数据发送到阻塞队列中，进行存储，单个线程进行处理
 中断时程序不再响应，返回失败，同时将缓存中的数据全部发送到阻塞队列，~~并添加毒丸，~~线程记录中断时已取消及未完成的任务，执行完毕后程序停止。
 
1000 1000 1000 1000

